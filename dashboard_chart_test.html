<!DOCTYPE html>
<html>
<head>
    <title>Dashboard Chart Test</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .position-card { border: 1px solid #ccc; padding: 20px; margin: 20px 0; border-radius: 8px; }
        .position-chart { margin: 10px 0; }
        .chart-container { position: relative; }
        canvas { border: 1px solid #333; }
        .chart-overlay { position: absolute; top: 0; left: 0; right: 0; bottom: 0; pointer-events: none; }
        .entry-line { position: absolute; width: 100%; height: 1px; background: #9966ff; }
        .line-label { position: absolute; right: 0; top: -20px; font-size: 12px; color: #9966ff; }
        .debug { background: #f0f0f0; padding: 10px; margin: 10px 0; font-family: monospace; }
    </style>
</head>
<body>
    <h1>Dashboard Chart Test</h1>
    
    <div class="debug" id="debug-info">Initializing...</div>
    
    <!-- Mock position cards with the exact structure from dashboard.html -->
    <div class="position-card">
        <h3>BTC/USD Position</h3>
        <div class="position-chart">
            <div class="chart-container">
                <canvas id="chart-BTC-USD" width="300" height="100"></canvas>
                <div class="chart-overlay">
                    <div class="entry-line" style="top: 50%;">
                        <div class="line-label">Entry: $112,427.80</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <div class="position-card">
        <h3>ETH/USD Position</h3>
        <div class="position-chart">
            <div class="chart-container">
                <canvas id="chart-ETH-USD" width="300" height="100"></canvas>
                <div class="chart-overlay">
                    <div class="entry-line" style="top: 50%;">
                        <div class="line-label">Entry: $4,476.16</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Mock the exact position data from the dashboard
        window.positionData = {
            "BTC/USD": {
                symbol: "BTC/USD",
                side: "short",
                size: 0.0089,
                entry_price: 112427.8,
                current_price: 110811.8,
                pnl: 1.4373669145887404,
                pnl_value: 14.3824,
                current_value: 986.22502,
                chart_min: 105271.20999999999,
                chart_max: 118049.19,
                trend_strength: "moderate",
                r_squared: 72.87473382917749
            },
            "ETH/USD": {
                symbol: "ETH/USD",
                side: "short",
                size: 0.1408,
                entry_price: 4476.16,
                current_price: 4292.91,
                pnl: 4.093910852158993,
                pnl_value: 25.8016,
                current_value: 604.441728,
                chart_min: 4078.2644999999998,
                chart_max: 4699.968,
                trend_strength: "strong",
                r_squared: 78.18782170431798
            }
        };
        
        const debugInfo = document.getElementById('debug-info');
        
        function log(message) {
            console.log(message);
            debugInfo.innerHTML += message + '<br>';
        }
        
        // Mock the fetchRealChartData function
        async function fetchRealChartData(symbol, position) {
            try {
                log('Fetching chart data for ' + symbol + ' with 5m interval');
                
                // Mock API response with realistic data
                const mockCandles = [
                    { close: 112000 },
                    { close: 111500 },
                    { close: 111000 },
                    { close: 110500 },
                    { close: 110000 },
                    { close: 109500 },
                    { close: 109000 },
                    { close: 108500 },
                    { close: 108000 },
                    { close: 107500 }
                ];
                
                log('Received mock data for ' + symbol + ': ' + mockCandles.length + ' candles');
                
                // Convert candle data to price array
                const prices = mockCandles.map(candle => parseFloat(candle.close));
                log('Converted to prices array for ' + symbol + ': ' + prices.length + ' points');
                return prices;
            } catch (error) {
                log('Failed to fetch real chart data for ' + symbol + ': ' + error);
                return null;
            }
        }
        
        // Mock the chart creation function (exact copy from dashboard.html)
        function createPositionChart(canvasId, position) {
            return new Promise((resolve) => {
                log('Creating chart for ' + position.symbol);

                const canvas = document.getElementById(canvasId);
                if (!canvas) {
                    log('Canvas not found: ' + canvasId);
                    resolve();
                    return;
                }

                const ctx = canvas.getContext('2d');
                if (!ctx) {
                    log('Canvas context not available: ' + canvasId);
                    resolve();
                    return;
                }

                // Set canvas size
                canvas.width = 300;
                canvas.height = 100;

                // Clear canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // Fetch real historical data only
                fetchRealChartData(position.symbol, position)
                    .then(chartData => {
                        if (chartData && chartData.length > 0) {
                            log('Using real data for ' + position.symbol + ': ' + chartData.length + ' points');
                            // chartData is already an array of prices from fetchRealChartData
                            const prices = chartData;
                            const minPrice = Math.min(...prices, position.entry_price);
                            const maxPrice = Math.max(...prices, position.entry_price);
                            // Update entry line position for real data
                            updateEntryLinePosition(canvas, position.entry_price, minPrice, maxPrice);
                            drawEnhancedChart(ctx, canvas, prices, position.entry_price, minPrice, maxPrice, position.pnl >= 0);
                        } else {
                            log('No real data available for ' + position.symbol);
                            drawErrorChart(ctx, canvas, 'No data available');
                        }
                        resolve();
                    })
                    .catch(error => {
                        log('Failed to fetch real data for ' + position.symbol + ': ' + error);
                        drawErrorChart(ctx, canvas, 'Failed to load data');
                        resolve();
                    });
            });
        }
        
        // Mock the drawEnhancedChart function
        function drawEnhancedChart(ctx, canvas, prices, entryPrice, minPrice, maxPrice, isPositive) {
            const width = canvas.width;
            const height = canvas.height;
            const padding = 15;
            
            // Find min/max prices
            const priceRange = maxPrice - minPrice;
            
            if (priceRange === 0) {
                // Draw flat line if no range
                ctx.strokeStyle = isPositive ? '#00ff88' : '#ff4444';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(padding, height / 2);
                ctx.lineTo(width - padding, height / 2);
                ctx.stroke();
                return;
            }
            
            // Create gradient for the price line
            const gradient = ctx.createLinearGradient(0, 0, width, 0);
            gradient.addColorStop(0, isPositive ? 'rgba(0, 255, 136, 0.8)' : 'rgba(255, 68, 68, 0.8)');
            gradient.addColorStop(1, isPositive ? 'rgba(0, 255, 136, 1)' : 'rgba(255, 68, 68, 1)');
            
            // Draw price line with gradient
            ctx.strokeStyle = gradient;
            ctx.lineWidth = 2;
            ctx.beginPath();
            
            for (let i = 0; i < prices.length; i++) {
                const x = padding + (i / (prices.length - 1)) * (width - 2 * padding);
                const y = height - padding - ((prices[i] - minPrice) / priceRange) * (height - 2 * padding);
                
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.stroke();
            
            // Draw entry line with purple dashed style
            const entryY = height - padding - ((entryPrice - minPrice) / priceRange) * (height - 2 * padding);
            ctx.strokeStyle = '#9966ff';
            ctx.lineWidth = 1;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(padding, entryY);
            ctx.lineTo(width - padding, entryY);
            ctx.stroke();
            ctx.setLineDash([]);
            
            log('Enhanced chart drawn for ' + prices.length + ' data points');
        }
        
        function drawErrorChart(ctx, canvas, message) {
            const width = canvas.width;
            const height = canvas.height;

            // Clear canvas
            ctx.clearRect(0, 0, width, height);

            // Set error styling
            ctx.fillStyle = 'rgba(239, 68, 68, 0.1)';
            ctx.fillRect(0, 0, width, height);

            // Draw error border
            ctx.strokeStyle = '#ef4444';
            ctx.lineWidth = 2;
            ctx.strokeRect(0, 0, width, height);

            // Draw error text
            ctx.fillStyle = '#ef4444';
            ctx.font = '12px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(message, width / 2, height / 2);

            // Draw error icon
            ctx.fillStyle = 'white';
            ctx.font = '10px Arial';
            ctx.fillText('!', width / 2, height / 2 - 16);
        }
        
        function updateEntryLinePosition(canvas, entryPrice, minPrice, maxPrice) {
            const positionCard = canvas.closest('.position-card');
            if (positionCard) {
                const entryLine = positionCard.querySelector('.entry-line');
                if (entryLine) {
                    const priceRange = maxPrice - minPrice;
                    if (priceRange > 0) {
                        const topPercent = (1 - (entryPrice - minPrice) / priceRange) * 100;
                        entryLine.style.top = topPercent + '%';
                    }
                }
            }
        }
        
        // Mock the chart queue system
        let chartQueue = [];
        let isProcessingQueue = false;
        
        function addToChartQueue(canvas, position) {
            chartQueue.push({ canvas, position });
            processChartQueue();
        }
        
        function processChartQueue() {
            if (isProcessingQueue || chartQueue.length === 0) {
                return;
            }

            isProcessingQueue = true;

            const { canvas, position } = chartQueue.shift();
            log('Processing chart for ' + position.symbol);

            createPositionChart(canvas.id, position).finally(() => {
                isProcessingQueue = false;
                // Small delay between requests to avoid overwhelming the server
                setTimeout(() => {
                    processChartQueue();
                }, 100);
            });
        }
        
        // Initialize charts (exact copy from dashboard.html)
        document.addEventListener('DOMContentLoaded', function() {
            log('Initializing position charts...');

            // Wait a bit for DOM to be fully ready
            setTimeout(() => {
                const canvases = document.querySelectorAll('canvas[id^="chart-"]');
                log('Found ' + canvases.length + ' chart canvases');

                canvases.forEach((canvas, index) => {
                    const symbol = canvas.id.replace('chart-', '').replace(/-/g, '/');
                    log('Queueing chart ' + (index + 1) + '/' + canvases.length + ' for ' + symbol);

                    const positionCard = canvas.closest('.position-card');
                    if (positionCard) {
                        // Get position data from the card's data attributes or extract from backend data
                        const positionData = window.positionData || {};
                        const position = positionData[symbol];

                        if (position) {
                            log('Using backend data for ' + symbol);
                            addToChartQueue(canvas, position);
                        } else {
                            log('Backend data not available for ' + symbol + ', using DOM extraction');
                        }
                    } else {
                        log('No position card found for ' + symbol);
                    }
                });
            }, 100);
        });
    </script>
</body>
</html>
