"""
Momentum Exploitation Strategy for Maximum Profit in Shortest Time

This strategy identifies and exploits momentum shifts in the market, focusing on
rapid price movements and volume spikes for quick profit capture.
"""

from typing import Optional, Tuple, Dict, Any
import pandas as pd
import numpy as np
import ta
from dataclasses import dataclass

from crypto_bot.utils.volatility import normalize_score_by_volatility
from crypto_bot.utils.indicator_cache import cache_series


@dataclass
class MomentumExploiterConfig:
    """Configuration for momentum exploitation strategy."""
    
    # Core settings
    lookback: int = 10
    threshold: float = 0.01
    max_positions: int = 25
    
    # Risk management
    stop_loss_pct: float = 0.008
    take_profit_pct: float = 0.035
    
    # Momentum detection
    momentum_window: int = 8
    momentum_threshold: float = 0.005
    volume_spike_mult: float = 2.0
    
    # Technical indicators
    rsi_window: int = 8
    rsi_oversold: float = 25.0
    rsi_overbought: float = 75.0
    
    # Volume analysis
    volume_window: int = 12
    volume_zscore_threshold: float = 1.5
    
    # Price action
    price_change_window: int = 5
    acceleration_threshold: float = 0.003
    
    # Filters
    min_atr_pct: float = 0.0005
    max_spread_pct: float = 0.5
    
    def __post_init__(self):
        """Validate configuration after initialization."""
        if self.stop_loss_pct >= self.take_profit_pct:
            raise ValueError("Stop loss must be less than take profit")
        if self.threshold < 0:
            raise ValueError("Threshold must be positive")


def _calculate_momentum_indicators(df: pd.DataFrame, config: MomentumExploiterConfig) -> Dict[str, pd.Series]:
    """Calculate momentum-related technical indicators."""
    
    indicators = {}
    
    # Price momentum
    indicators['price_change'] = df['close'].pct_change()
    indicators['price_momentum'] = df['close'].pct_change(periods=config.momentum_window)
    
    # Price acceleration (second derivative)
    indicators['price_acceleration'] = indicators['price_change'].diff()
    
    # Volume momentum
    indicators['volume_change'] = df['volume'].pct_change()
    indicators['volume_sma'] = df['volume'].rolling(window=config.volume_window).mean()
    indicators['volume_zscore'] = (
        (df['volume'] - indicators['volume_sma']) / 
        df['volume'].rolling(window=config.volume_window).std()
    )
    
    # RSI for momentum confirmation
    indicators['rsi'] = ta.momentum.rsi(df['close'], window=config.rsi_window)
    
    # ATR for volatility measurement
    indicators['atr'] = ta.volatility.average_true_range(
        df['high'], df['low'], df['close'], window=config.momentum_window
    )
    
    # Bollinger Bands for momentum extremes
    bb = ta.volatility.BollingerBands(df['close'], window=config.momentum_window, window_dev=2)
    indicators['bb_upper'] = bb.bollinger_hband()
    indicators['bb_lower'] = bb.bollinger_lband()
    indicators['bb_width'] = (indicators['bb_upper'] - indicators['bb_lower']) / df['close']
    
    # MACD for momentum confirmation
    macd = ta.trend.MACD(df['close'], window_fast=8, window_slow=16, window_sign=6)
    indicators['macd'] = macd.macd()
    indicators['macd_signal'] = macd.macd_signal()
    indicators['macd_histogram'] = macd.macd_diff()
    
    # Stochastic for momentum extremes
    stoch = ta.momentum.StochasticOscillator(
        df['high'], df['low'], df['close'], window=config.momentum_window, smooth_window=3
    )
    indicators['stoch_k'] = stoch.stoch()
    indicators['stoch_d'] = stoch.stoch_signal()
    
    return indicators


def _detect_momentum_signals(
    df: pd.DataFrame, 
    indicators: Dict[str, pd.Series], 
    config: MomentumExploiterConfig
) -> Tuple[float, str, Dict[str, Any]]:
    """Detect momentum exploitation trading signals."""
    
    if len(df) < max(config.lookback, config.momentum_window, config.volume_window):
        return 0.0, "none", {}
    
    # Get latest values
    current = {k: v.iloc[-1] for k, v in indicators.items()}
    prev = {k: v.iloc[-2] for k, v in indicators.items()}
    
    # Initialize signal components
    signal_strength = 0.0
    signal_direction = "none"
    signal_metadata = {}
    
    # 1. Price Momentum Detection
    if current['price_momentum'] > config.momentum_threshold:
        signal_strength += 0.25
        signal_direction = "long"
        signal_metadata['momentum_type'] = "price_bullish"
        signal_metadata['momentum_strength'] = current['price_momentum']
    elif current['price_momentum'] < -config.momentum_threshold:
        signal_strength += 0.25
        signal_direction = "short"
        signal_metadata['momentum_type'] = "price_bearish"
        signal_metadata['momentum_strength'] = current['price_momentum']
    
    # 2. Price Acceleration (Second Derivative)
    if current['price_acceleration'] > config.acceleration_threshold:
        signal_strength += 0.2
        if signal_direction == "none":
            signal_direction = "long"
        signal_metadata['acceleration'] = "increasing"
        signal_metadata['acceleration_value'] = current['price_acceleration']
    elif current['price_acceleration'] < -config.acceleration_threshold:
        signal_strength += 0.2
        if signal_direction == "none":
            signal_direction = "short"
        signal_metadata['acceleration'] = "decreasing"
        signal_metadata['acceleration_value'] = current['price_acceleration']
    
    # 3. Volume Spike Confirmation
    if current['volume_zscore'] > config.volume_zscore_threshold:
        signal_strength += 0.2
        signal_metadata['volume_spike'] = current['volume_zscore']
        
        # Volume-price divergence check
        if (signal_direction == "long" and current['price_change'] > 0) or \
           (signal_direction == "short" and current['price_change'] < 0):
            signal_strength += 0.1
            signal_metadata['volume_price_aligned'] = True
    
    # 4. RSI Momentum Confirmation
    if signal_direction == "long" and current['rsi'] < config.rsi_oversold:
        signal_strength += 0.15
        signal_metadata['rsi_confirmation'] = "oversold_bounce"
    elif signal_direction == "short" and current['rsi'] > config.rsi_overbought:
        signal_strength += 0.15
        signal_metadata['rsi_confirmation'] = "overbought_rejection"
    
    # 5. Bollinger Band Momentum
    if signal_direction == "long" and df['close'].iloc[-1] < current['bb_lower']:
        signal_strength += 0.1
        signal_metadata['bb_signal'] = "below_lower_band"
    elif signal_direction == "short" and df['close'].iloc[-1] > current['bb_upper']:
        signal_strength += 0.1
        signal_metadata['bb_signal'] = "above_upper_band"
    
    # 6. MACD Momentum Confirmation
    if (signal_direction == "long" and 
        current['macd'] > current['macd_signal'] and 
        prev['macd'] <= prev['macd_signal']):
        signal_strength += 0.1
        signal_metadata['macd_signal'] = "bullish_crossover"
    elif (signal_direction == "short" and 
          current['macd'] < current['macd_signal'] and 
          prev['macd'] >= prev['macd_signal']):
        signal_strength += 0.1
        signal_metadata['macd_signal'] = "bearish_crossover"
    
    # 7. Stochastic Momentum
    if signal_direction == "long" and current['stoch_k'] < 20:
        signal_strength += 0.1
        signal_metadata['stoch_signal'] = "oversold"
    elif signal_direction == "short" and current['stoch_k'] > 80:
        signal_strength += 0.1
        signal_metadata['stoch_signal'] = "overbought"
    
    # 8. Volatility Filter
    if current['atr'] is not None and not np.isnan(current['atr']):
        atr_pct = current['atr'] / df['close'].iloc[-1]
        if atr_pct > config.min_atr_pct:
            signal_strength += 0.1
            signal_metadata['atr_pct'] = atr_pct
        else:
            # Reduce signal strength if volatility is too low
            signal_strength *= 0.7
            signal_metadata['low_volatility'] = True
    
    # Normalize signal strength
    signal_strength = min(signal_strength, 1.0)
    
    # Apply threshold filter
    if signal_strength < config.threshold:
        return 0.0, "none", {}
    
    # Add additional metadata
    signal_metadata.update({
        'signal_strength': signal_strength,
        'timestamp': df.index[-1] if hasattr(df.index[-1], 'timestamp') else None,
        'price': df['close'].iloc[-1],
        'volume': df['volume'].iloc[-1],
        'price_change_1m': current['price_change'],
        'price_momentum': current['price_momentum']
    })
    
    return signal_strength, signal_direction, signal_metadata


def generate_signal(
    df: pd.DataFrame,
    config: Optional[Dict[str, Any]] = None,
    **kwargs
) -> Tuple[float, str, Dict[str, Any]]:
    """
    Generate momentum exploitation trading signals.
    
    Parameters
    ----------
    df : pd.DataFrame
        OHLCV data with columns: open, high, low, close, volume
    config : dict, optional
        Configuration dictionary
    **kwargs
        Additional keyword arguments
        
    Returns
    -------
    Tuple[float, str, Dict[str, Any]]
        (signal_score, direction, metadata)
    """
    
    # Create configuration
    if config is None:
        config = {}
    
    # Merge with defaults
    momentum_config = MomentumExploiterConfig(**{**MomentumExploiterConfig().__dict__, **config})
    
    # Validate data
    if df.empty or len(df) < momentum_config.lookback:
        return 0.0, "none", {}
    
    required_columns = ['open', 'high', 'low', 'close', 'volume']
    if not all(col in df.columns for col in required_columns):
        return 0.0, "none", {}
    
    # Calculate indicators
    try:
        indicators = _calculate_momentum_indicators(df, momentum_config)
    except Exception as e:
        return 0.0, "none", {"error": str(e)}
    
    # Detect signals
    try:
        signal_score, direction, metadata = _detect_momentum_signals(
            df, indicators, momentum_config
        )
    except Exception as e:
        return 0.0, "none", {"error": str(e)}
    
    # Apply volatility normalization if enabled
    if 'atr_pct' in metadata:
        try:
            signal_score = normalize_score_by_volatility(
                signal_score, metadata['atr_pct']
            )
        except:
            pass  # Continue without normalization if it fails
    
    # Ensure signal score is within bounds
    signal_score = max(0.0, min(1.0, signal_score))
    
    return signal_score, direction, metadata


def get_strategy_info() -> Dict[str, Any]:
    """Get strategy information and metadata."""
    return {
        "name": "momentum_exploiter",
        "description": "Momentum exploitation strategy for capturing rapid price movements",
        "timeframe": "1m-5m",
        "risk_level": "high",
        "profit_potential": "very_high",
        "speed": "fast",
        "suitable_for": ["experienced_traders", "momentum_trading", "quick_profits"],
        "key_features": [
            "Momentum shift detection",
            "Price acceleration analysis",
            "Volume spike confirmation",
            "Multi-indicator momentum confirmation",
            "Fast profit capture",
            "High concurrent positions (25)"
        ],
        "risk_warnings": [
            "High risk due to momentum dependency",
            "Requires quick execution",
            "May miss momentum reversals",
            "Suitable for experienced traders",
            "Requires good market timing"
        ]
    }
