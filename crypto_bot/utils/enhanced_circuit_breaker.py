"""
Enhanced Circuit Breaker - Advanced Risk Management System

This module provides a sophisticated circuit breaker implementation that monitors
trading performance, market conditions, and system health to prevent catastrophic
losses and ensure system stability.
"""

import asyncio
import threading
import logging
import json
from typing import Dict, List, Optional, Any, Callable
from dataclasses import dataclass, field
from datetime import datetime, timedelta
from enum import Enum
from pathlib import Path
import statistics

logger = logging.getLogger(__name__)

class CircuitState(Enum):
    """Circuit breaker states."""
    CLOSED = "closed"      # Normal operation
    OPEN = "open"         # Circuit is open, no trading
    HALF_OPEN = "half_open"  # Testing if circuit can close

@dataclass
class CircuitBreakerConfig:
    """Configuration for circuit breaker."""
    # Failure thresholds
    failure_threshold: int = 5
    failure_window_seconds: int = 300  # 5 minutes
    
    # Recovery settings
    recovery_timeout_seconds: int = 600  # 10 minutes
    success_threshold: int = 3
    
    # Performance thresholds
    max_drawdown_percent: float = 10.0
    max_loss_per_trade_percent: float = 5.0
    max_daily_loss_percent: float = 15.0
    
    # Market condition thresholds
    max_volatility_percent: float = 50.0
    min_liquidity_threshold: float = 1000.0
    
    # System health thresholds
    max_memory_usage_percent: float = 80.0
    max_cpu_usage_percent: float = 80.0
    max_api_error_rate: float = 0.1  # 10%
    
    # Notification settings
    enable_notifications: bool = True
    notification_cooldown_seconds: int = 300  # 5 minutes

@dataclass
class CircuitBreakerMetrics:
    """Metrics tracked by circuit breaker."""
    total_trades: int = 0
    successful_trades: int = 0
    failed_trades: int = 0
    total_pnl: float = 0.0
    max_drawdown: float = 0.0
    current_drawdown: float = 0.0
    peak_balance: float = 0.0
    current_balance: float = 0.0
    daily_loss: float = 0.0
    api_errors: int = 0
    api_requests: int = 0
    memory_usage: float = 0.0
    cpu_usage: float = 0.0
    last_trade_time: Optional[datetime] = None
    last_error_time: Optional[datetime] = None
    
    def copy(self):
        """Create a copy of the metrics."""
        return CircuitBreakerMetrics(
            total_trades=self.total_trades,
            successful_trades=self.successful_trades,
            failed_trades=self.failed_trades,
            total_pnl=self.total_pnl,
            max_drawdown=self.max_drawdown,
            current_drawdown=self.current_drawdown,
            peak_balance=self.peak_balance,
            current_balance=self.current_balance,
            daily_loss=self.daily_loss,
            api_errors=self.api_errors,
            api_requests=self.api_requests,
            memory_usage=self.memory_usage,
            cpu_usage=self.cpu_usage,
            last_trade_time=self.last_trade_time,
            last_error_time=self.last_error_time
        )

@dataclass
class CircuitBreakerEvent:
    """Event generated by circuit breaker."""
    event_type: str
    timestamp: datetime
    state: CircuitState
    reason: str
    metrics: CircuitBreakerMetrics
    details: Dict[str, Any] = field(default_factory=dict)

class EnhancedCircuitBreaker:
    """
    Enhanced circuit breaker with comprehensive monitoring and risk management.
    
    This circuit breaker monitors:
    - Trading performance (PnL, drawdown, win rate)
    - Market conditions (volatility, liquidity)
    - System health (memory, CPU, API errors)
    - Risk metrics (position sizing, exposure)
    """
    
    def __init__(self, config: CircuitBreakerConfig = None):
        self.config = config or CircuitBreakerConfig()
        self.state = CircuitState.CLOSED
        self.lock = threading.RLock()
        
        # Metrics tracking
        self.metrics = CircuitBreakerMetrics()
        self.failure_history: List[datetime] = []
        self.success_history: List[datetime] = []
        self.event_history: List[CircuitBreakerEvent] = []
        
        # State management
        self.state_change_time = datetime.now()
        self.last_notification_time = datetime.now()
        
        # Monitoring tasks
        self.monitoring_task = None
        self.running = False
        
        # Callbacks
        self.state_change_callbacks: List[Callable] = []
        self.alert_callbacks: List[Callable] = []
        
        # Performance tracking
        self.daily_pnl_history: List[float] = []
        self.trade_history: List[Dict[str, Any]] = []
        
        logger.info("Enhanced Circuit Breaker initialized")
    
    async def start_monitoring(self):
        """Start continuous monitoring."""
        if not self.running:
            self.running = True
            self.monitoring_task = asyncio.create_task(self._monitoring_loop())
            logger.info("Circuit breaker monitoring started")
    
    async def stop_monitoring(self):
        """Stop continuous monitoring."""
        self.running = False
        if self.monitoring_task:
            self.monitoring_task.cancel()
            try:
                await self.monitoring_task
            except asyncio.CancelledError:
                pass
            self.monitoring_task = None
            logger.info("Circuit breaker monitoring stopped")
    
    async def _monitoring_loop(self):
        """Continuous monitoring loop."""
        while self.running:
            try:
                # Check various conditions
                await self._check_trading_performance()
                await self._check_market_conditions()
                await self._check_system_health()
                await self._check_risk_metrics()
                
                # Update state if needed
                await self._update_state()
                
                # Log metrics periodically
                if self.metrics.total_trades % 10 == 0:
                    self._log_metrics()
                
                await asyncio.sleep(5)  # Check every 5 seconds
                
            except Exception as e:
                logger.error(f"Error in circuit breaker monitoring: {e}")
                await asyncio.sleep(10)
    
    async def _check_trading_performance(self):
        """Check trading performance metrics."""
        with self.lock:
            # Calculate drawdown
            if self.metrics.current_balance > self.metrics.peak_balance:
                self.metrics.peak_balance = self.metrics.current_balance
            
            if self.metrics.peak_balance > 0:
                self.metrics.current_drawdown = (
                    (self.metrics.peak_balance - self.metrics.current_balance) / 
                    self.metrics.peak_balance * 100
                )
                self.metrics.max_drawdown = max(
                    self.metrics.max_drawdown, 
                    self.metrics.current_drawdown
                )
            
            # Check drawdown threshold
            if self.metrics.current_drawdown > self.config.max_drawdown_percent:
                await self._trigger_circuit_open(
                    "drawdown_exceeded",
                    f"Drawdown {self.metrics.current_drawdown:.2f}% exceeds threshold {self.config.max_drawdown_percent}%"
                )
            
            # Check daily loss
            if self.metrics.daily_loss < -self.config.max_daily_loss_percent:
                await self._trigger_circuit_open(
                    "daily_loss_exceeded",
                    f"Daily loss {abs(self.metrics.daily_loss):.2f}% exceeds threshold {self.config.max_daily_loss_percent}%"
                )
    
    async def _check_market_conditions(self):
        """Check market conditions."""
        # This would integrate with market data providers
        # For now, we'll use placeholder logic
        
        # Check volatility (would be calculated from price data)
        volatility = 0.0  # Placeholder
        if volatility > self.config.max_volatility_percent:
            await self._trigger_circuit_open(
                "high_volatility",
                f"Volatility {volatility:.2f}% exceeds threshold {self.config.max_volatility_percent}%"
            )
        
        # Check liquidity (would be calculated from order book data)
        liquidity = 10000.0  # Placeholder
        if liquidity < self.config.min_liquidity_threshold:
            await self._trigger_circuit_open(
                "low_liquidity",
                f"Liquidity {liquidity:.2f} below threshold {self.config.min_liquidity_threshold}"
            )
    
    async def _check_system_health(self):
        """Check system health metrics."""
        # Check API error rate
        if self.metrics.api_requests > 0:
            error_rate = self.metrics.api_errors / self.metrics.api_requests
            if error_rate > self.config.max_api_error_rate:
                await self._trigger_circuit_open(
                    "high_api_error_rate",
                    f"API error rate {error_rate:.2%} exceeds threshold {self.config.max_api_error_rate:.2%}"
                )
        
        # Check memory usage (would integrate with system monitoring)
        if self.metrics.memory_usage > self.config.max_memory_usage_percent:
            await self._trigger_circuit_open(
                "high_memory_usage",
                f"Memory usage {self.metrics.memory_usage:.1f}% exceeds threshold {self.config.max_memory_usage_percent}%"
            )
        
        # Check CPU usage (would integrate with system monitoring)
        if self.metrics.cpu_usage > self.config.max_cpu_usage_percent:
            await self._trigger_circuit_open(
                "high_cpu_usage",
                f"CPU usage {self.metrics.cpu_usage:.1f}% exceeds threshold {self.config.max_cpu_usage_percent}%"
            )
    
    async def _check_risk_metrics(self):
        """Check risk metrics."""
        # Check recent trade performance
        if len(self.trade_history) > 0:
            recent_trades = self.trade_history[-10:]  # Last 10 trades
            recent_losses = [t for t in recent_trades if t.get('pnl', 0) < 0]
            
            if len(recent_losses) >= self.config.failure_threshold:
                await self._trigger_circuit_open(
                    "consecutive_losses",
                    f"{len(recent_losses)} consecutive losses exceed threshold {self.config.failure_threshold}"
                )
    
    async def _update_state(self):
        """Update circuit breaker state based on conditions."""
        with self.lock:
            if self.state == CircuitState.OPEN:
                # Check if recovery timeout has passed
                time_since_open = (datetime.now() - self.state_change_time).total_seconds()
                if time_since_open >= self.config.recovery_timeout_seconds:
                    await self._transition_to_half_open()
            
            elif self.state == CircuitState.HALF_OPEN:
                # Check if we have enough successful operations
                recent_successes = [
                    s for s in self.success_history 
                    if (datetime.now() - s).total_seconds() < self.config.failure_window_seconds
                ]
                
                if len(recent_successes) >= self.config.success_threshold:
                    await self._transition_to_closed()
    
    async def _trigger_circuit_open(self, reason: str, details: str):
        """Trigger circuit to open state."""
        if self.state != CircuitState.OPEN:
            await self._transition_to_open(reason, details)
    
    async def _transition_to_open(self, reason: str, details: str):
        """Transition circuit to open state."""
        with self.lock:
            if self.state != CircuitState.OPEN:
                old_state = self.state
                self.state = CircuitState.OPEN
                self.state_change_time = datetime.now()
                
                event = CircuitBreakerEvent(
                    event_type="circuit_opened",
                    timestamp=datetime.now(),
                    state=self.state,
                    reason=reason,
                    metrics=self.metrics.copy(),
                    details={"details": details}
                )
                self.event_history.append(event)
                
                logger.warning(f"Circuit breaker opened: {reason} - {details}")
                
                # Notify callbacks
                await self._notify_state_change(old_state, self.state, reason, details)
    
    async def _transition_to_half_open(self):
        """Transition circuit to half-open state."""
        with self.lock:
            if self.state == CircuitState.OPEN:
                old_state = self.state
                self.state = CircuitState.HALF_OPEN
                self.state_change_time = datetime.now()
                
                event = CircuitBreakerEvent(
                    event_type="circuit_half_open",
                    timestamp=datetime.now(),
                    state=self.state,
                    reason="recovery_timeout",
                    metrics=self.metrics.copy()
                )
                self.event_history.append(event)
                
                logger.info("Circuit breaker transitioned to half-open state")
                
                # Notify callbacks
                await self._notify_state_change(old_state, self.state, "recovery_timeout", "")
    
    async def _transition_to_closed(self):
        """Transition circuit to closed state."""
        with self.lock:
            if self.state == CircuitState.HALF_OPEN:
                old_state = self.state
                self.state = CircuitState.CLOSED
                self.state_change_time = datetime.now()
                
                event = CircuitBreakerEvent(
                    event_type="circuit_closed",
                    timestamp=datetime.now(),
                    state=self.state,
                    reason="success_threshold_met",
                    metrics=self.metrics.copy()
                )
                self.event_history.append(event)
                
                logger.info("Circuit breaker closed - normal operation resumed")
                
                # Notify callbacks
                await self._notify_state_change(old_state, self.state, "success_threshold_met", "")
    
    async def _notify_state_change(self, old_state: CircuitState, new_state: CircuitState, 
                                  reason: str, details: str):
        """Notify state change callbacks."""
        for callback in self.state_change_callbacks:
            try:
                await callback(old_state, new_state, reason, details)
            except Exception as e:
                logger.error(f"Error in state change callback: {e}")
    
    def record_trade(self, symbol: str, side: str, size: float, price: float, 
                    pnl: float = 0.0, success: bool = True):
        """Record a trade for monitoring."""
        with self.lock:
            self.metrics.total_trades += 1
            self.metrics.last_trade_time = datetime.now()
            
            if success:
                self.metrics.successful_trades += 1
                self.success_history.append(datetime.now())
            else:
                self.metrics.failed_trades += 1
                self.failure_history.append(datetime.now())
            
            # Update PnL and balance
            self.metrics.total_pnl += pnl
            self.metrics.current_balance += pnl
            
            # Update peak balance if current balance is higher
            if self.metrics.current_balance > self.metrics.peak_balance:
                self.metrics.peak_balance = self.metrics.current_balance
            
            # Calculate current drawdown
            if self.metrics.peak_balance > 0:
                self.metrics.current_drawdown = (
                    (self.metrics.peak_balance - self.metrics.current_balance) / 
                    self.metrics.peak_balance * 100
                )
                self.metrics.max_drawdown = max(
                    self.metrics.max_drawdown, 
                    self.metrics.current_drawdown
                )
            
            # Record trade
            trade_record = {
                'timestamp': datetime.now().isoformat(),
                'symbol': symbol,
                'side': side,
                'size': size,
                'price': price,
                'pnl': pnl,
                'success': success
            }
            self.trade_history.append(trade_record)
            
            # Clean up old history
            self._cleanup_history()
    
    def record_api_error(self):
        """Record an API error."""
        with self.lock:
            self.metrics.api_errors += 1
            self.metrics.last_error_time = datetime.now()
    
    def record_api_request(self):
        """Record an API request."""
        with self.lock:
            self.metrics.api_requests += 1
    
    def update_system_metrics(self, memory_usage: float, cpu_usage: float):
        """Update system health metrics."""
        with self.lock:
            self.metrics.memory_usage = memory_usage
            self.metrics.cpu_usage = cpu_usage
    
    def update_daily_pnl(self, daily_pnl: float):
        """Update daily PnL."""
        with self.lock:
            self.metrics.daily_loss = daily_pnl
            self.daily_pnl_history.append(daily_pnl)
    
    def is_trading_allowed(self) -> bool:
        """Check if trading is currently allowed."""
        return self.state == CircuitState.CLOSED
    
    def get_state(self) -> CircuitState:
        """Get current circuit breaker state."""
        return self.state
    
    def get_metrics(self) -> CircuitBreakerMetrics:
        """Get current metrics."""
        with self.lock:
            return self.metrics
    
    def get_event_history(self) -> List[CircuitBreakerEvent]:
        """Get event history."""
        with self.lock:
            return self.event_history.copy()
    
    def add_state_change_callback(self, callback: Callable):
        """Add a callback for state changes."""
        self.state_change_callbacks.append(callback)
    
    def add_alert_callback(self, callback: Callable):
        """Add a callback for alerts."""
        self.alert_callbacks.append(callback)
    
    def _cleanup_history(self):
        """Clean up old history entries."""
        cutoff_time = datetime.now() - timedelta(seconds=self.config.failure_window_seconds)
        
        # Clean failure history
        self.failure_history = [
            f for f in self.failure_history 
            if f > cutoff_time
        ]
        
        # Clean success history
        self.success_history = [
            s for s in self.success_history 
            if s > cutoff_time
        ]
        
        # Clean event history (keep last 100 events)
        if len(self.event_history) > 100:
            self.event_history = self.event_history[-100:]
        
        # Clean trade history (keep last 1000 trades)
        if len(self.trade_history) > 1000:
            self.trade_history = self.trade_history[-1000:]
    
    def _log_metrics(self):
        """Log current metrics."""
        logger.info(f"Circuit Breaker Metrics - "
                   f"State: {self.state.value}, "
                   f"Trades: {self.metrics.total_trades}, "
                   f"Success Rate: {self.metrics.successful_trades/max(1, self.metrics.total_trades)*100:.1f}%, "
                   f"Total PnL: {self.metrics.total_pnl:.2f}, "
                   f"Drawdown: {self.metrics.current_drawdown:.2f}%")
    
    def reset(self):
        """Reset circuit breaker to initial state."""
        with self.lock:
            self.state = CircuitState.CLOSED
            self.state_change_time = datetime.now()
            self.metrics = CircuitBreakerMetrics()
            self.failure_history.clear()
            self.success_history.clear()
            self.event_history.clear()
            self.trade_history.clear()
            self.daily_pnl_history.clear()
            logger.info("Circuit breaker reset to initial state")
    
    def export_metrics(self) -> Dict[str, Any]:
        """Export metrics for external monitoring."""
        with self.lock:
            return {
                'state': self.state.value,
                'metrics': {
                    'total_trades': self.metrics.total_trades,
                    'successful_trades': self.metrics.successful_trades,
                    'failed_trades': self.metrics.failed_trades,
                    'success_rate': self.metrics.successful_trades / max(1, self.metrics.total_trades),
                    'total_pnl': self.metrics.total_pnl,
                    'current_drawdown': self.metrics.current_drawdown,
                    'max_drawdown': self.metrics.max_drawdown,
                    'daily_loss': self.metrics.daily_loss,
                    'api_error_rate': self.metrics.api_errors / max(1, self.metrics.api_requests),
                    'memory_usage': self.metrics.memory_usage,
                    'cpu_usage': self.metrics.cpu_usage
                },
                'state_change_time': self.state_change_time.isoformat(),
                'last_trade_time': self.metrics.last_trade_time.isoformat() if self.metrics.last_trade_time else None,
                'last_error_time': self.metrics.last_error_time.isoformat() if self.metrics.last_error_time else None
            }
